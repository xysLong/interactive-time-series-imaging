<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curve Drawer</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            margin-top: 10px;
            border: 1px solid #000;
        }

        #plotContainer {
            margin-top: 10px;
            width: 300px;
            text-align: left;
        }
    </style>
</head>
<body>

<label for="plotType">Select Plot Type:</label>
<select id="plotType" onchange="changePlotType()">
    <option value="gasf">Gramian Angular Summation Field</option>
    <option value="gadf">Gramian Angular Difference Field</option>
    <option value="mtf8">Markov Transition Field (8 bins)</option>
    <option value="mtf16">Markov Transition Field (16 bins)</option>
</select>

<label for="colormap">Select Color Map:</label>
<select id="colormap" onchange="updatePlot()">
    <option value="seismic">seismic</option>
    <option value="viridis">viridis</option>
</select>

<div>
    <p>Draw an x-monotonic time series here:</p>
    <canvas id="curveCanvas" width="300" height="200"></canvas>
</div>

<div id="plotContainer"></div>

<script>
    let isDrawing = false;
    let coordinates = [];

    const canvas = document.getElementById('curveCanvas');
    const ctx = canvas.getContext('2d');

    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseleave', stopDrawing);

    function startDrawing(e) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        isDrawing = true;
        coordinates = [];
        coordinates.push({x: e.pageX - canvas.offsetLeft, y: e.pageY - canvas.offsetTop});
        ctx.beginPath();
        ctx.moveTo(e.pageX - canvas.offsetLeft, e.pageY - canvas.offsetTop);
    }

    function draw(e) {
        if (!isDrawing) return;
        coordinates.push({x: e.pageX - canvas.offsetLeft, y: e.pageY - canvas.offsetTop});
        ctx.lineTo(e.pageX - canvas.offsetLeft, e.pageY - canvas.offsetTop);
        ctx.stroke();
    }

    function stopDrawing() {
        if (!isDrawing) return;
        ctx.closePath();
        isDrawing = false;
        if (!isMonotonicallyIncreasing()) {
            alert('Warning: x values are not monotonically increasing!');
        } else {
            updatePlot();
        }
    }

    function changePlotType() {
        const plotType = document.getElementById('plotType').value.toString();
        document.getElementById("colormap").value = plotType.startsWith('mtf') ? 'viridis' : 'seismic';
        updatePlot();
    }

    function updatePlot() {
        const plotType = document.getElementById('plotType').value;
        const colorMap = document.getElementById('colormap').value;
        if (coordinates.length === 0) return;
        const plotContainer = document.getElementById('plotContainer');
        plotContainer.innerHTML = '';
        fetch('/process_coordinates', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                "coordinates": coordinates,
                "plotType": plotType,
                "colorMap": colorMap
            }),
        })
            .then(response => response.json())
            .then(data => {
                const minX = Math.min(...coordinates.map(point => point.x));
                const maxX = Math.max(...coordinates.map(point => point.x));
                const plotWidth = maxX - minX;
                const plotImage = new Image();
                plotImage.src = 'data:image/png;base64,' + data.image;
                plotImage.style.width = plotWidth + 'px';
                plotImage.style.height = plotWidth + 'px';
                plotImage.style.marginLeft = minX + 'px';
                console.log(minX, maxX, plotImage.style.width, plotImage.style.marginLeft);
                plotContainer.appendChild(plotImage);
            });
    }

    function isMonotonicallyIncreasing() {
        for (let i = 1; i < coordinates.length; i++) {
            if (coordinates[i].x < coordinates[i - 1].x) {
                return false;
            }
        }
        return true;
    }
</script>

</body>
</html>
